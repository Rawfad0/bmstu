/**
 * @file main.c
 * 
 * Реализовать линейный односвязный список с непрямым владением:
 * 1. Информационная часть узла представлена указателем на void.
 *      typedef struct node node_t;
 *      struct node
 *      {
 *          void *data;
 *          node_t *next;
 *      };
 * 2. Список формируется на основе данных, которые читаются из текстового файла. 
 * В качестве данных может, например, выступать информация о студенте: 
 * фамилия и год рождения. Область данных выбирается студентом самостоятельно 
 * и должна отличаться от указанного примера.
 * 3. Элементы списка данными не владеют, т. е. хранят лишь указатель на них.
 * При удалении элемента из списка данные из хранилища не удаляются.
 * 4. Для решения некоторых задач требуется функция сравнения элементов. 
 * Сравнение элементов реализуется как отдельная функция. 
 * Функции, нуждающиеся в сравнении элементов, получают в качестве параметра указатель на компаратор.
 * 5. Имена файлов, выполняемая операция и т. п. указываются через 
 * параметры командной строки, результаты работы записываются в файл.
 * 6. В качестве одного из необходимых результатов работы должно быть приведено 
 * условие осмысленной задачи в выбранной предметной области, которая
 * может быть решена с использованием разработанных вами функций (см. индивидуальное задание) 
 * и для решения которой достаточно того объёма данных, которые считываются из исходного файла. 
 * Также должна быть написана программа, решающая поставленную задачу.
 *
 * Две задачи на работу с одним элементом списка:
 * 1. Напишите функцию pop_end, которая возвращает указатель на данные из элемента, 
 * который расположен в «хвосте» списка. При этом из списка сам элемент удаляется.  (Относительная сложность: 1.)
 *      void* pop_back(node_t **head);
 * 2. Напишите функцию insert, которая вставляет элемент перед указанным элементом списка 
 * (в качестве параметров указываются адреса обоих элементов).                      (Относительная сложность: 2.)
 *      void insert(node_t **head, node_t *elem, node_t *before);
 *
 * Задача на работу с целым списком:
 * Напишите функцию reverse, которая обращает список. Идеи реализации:
 * Рекурсия.                                                                        (Относительная сложность: 2.)
 *      node_t* reverse(node_t *head); // возвращается «новая» голова
 * 
 * Сортировка списка:
 * Сортировка слиянием
 * Напишите функцию front_back_split, которая получает список и делит его на две половины. 
 * Если в списке нечетное число элементов, "серединный"элемент должен попасть в первую половину.
 *      void front_back_split(node_t* head, node_t** back);
 * Напишите функцию sorted_merge, которая получает два упорядоченных списка и объединяет их в один.
 *      node_t* sorted_merge(node_t **head_a, node_t **head_b, int (*comparator)(const void *, const void *));
 *      // Списки становятся пустыми, элементы из них
 *      // «переходят» в упорядоченный
 * Используя функции front_back_split и sorted_merge напишите функцию sort, 
 * которая реализует рекурсивный алгоритм сортировки слиянием.                      (Относительная сложность: 4.)
 * 
 */

#include "consts.h"
#include "film.h"
#include "list.h"

#define _POSIX_C_SOURCE 200809L
#include <string.h>

/**
 * Задача: считать список фильмов из файла, отсортирвоать их по возрастанию, удалить последний и записать в файл в обратном порядке. 
 */
int main(int argc, char **argv)
{
    if (argc != CORRECT_ARGC)
        return RC_INCORRECT_ARGC;

    node_t *film_list = NULL;
    int (*compar)(const void*, const void*) = compare_by_year;
    int rc = RC_OK;

    if ((rc = read_film_list(FILE_IN, &film_list)) != RC_OK);
    else
    {
        film_list = sort(film_list, compar);
        free_film(pop_back(&film_list));
        film_list = reverse(film_list);
        rc = write_film_list(FILE_OUT, film_list);
    }
    free_film_list(&film_list);

    return rc;
}
