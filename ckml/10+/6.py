"""
Нахождение комбинаций
Дан массив целых чисел. Ваша задача — написать функцию,
находящую все уникальные тройки чисел в массиве, сумма которых равна нулю.

Требования:
Напишите функцию three_sum_zero(arr), принимающую массив целых чисел в качестве входных данных
и возвращающую список всех уникальных троек чисел (список из трех чисел), сумма которых равна нулю.
Если такой комбинации нет, возвращается пустой список.

Функция должна эффективно обрабатывать большие массивы. Время выполнения вашей программы будет ограничено.

"""


# def three_sum_zero(arr):
#     d = dict()
#     res = []
#     for i in range(len(arr)):
#         for j in range(i + 1, len(arr)):
#             if d.get(- arr[i] - arr[j]):
#                 three = sorted([- arr[i] - arr[j], arr[i], arr[j]])
#                 # print(three)
#                 if three not in res:
#                     res.append(three)
#         d[arr[i]] = True
#     return res


"""
Примечание
Для эффективного решения задачи можно использовать подход, 
основанный на сортировке массива и использовании двух указателей. 
Сначала отсортируйте массив. Затем, для каждого элемента массива, 
используйте два указателя, один указывающий на следующий элемент, 
а другой — на последний элемент массива. 
Перемещайте указатели в зависимости от суммы трех элементов. 
Не забудьте обрабатывать дубликаты, чтобы избежать повторения троек в результате.

Шаблон решения данным методом (можете использовать):
"""


def three_sum_zero(arr):
    arr.sort()  # Сортируем массив
    result = []
    n = len(arr)
    for i in range(n - 2):
        # Суммы всех дальнейших троек будут положительными => не рассматриваем
        if arr[i] > 0:
            break
        # Пропускаем повторяющиеся числа для первого элемента
        if i > 0 and arr[i] == arr[i - 1]:
            continue
        # Используем два указателя для поиска оставшихся двух чисел
        j = i + 1
        k = n - 1
        while j < k:
            # Обработать текущую тройку чисел
            s = arr[i] + arr[j] + arr[k]
            if s < 0:
                j += 1  # сумму нужно увеличить => идем левым указателем вправо
            elif s > 0:
                k -= 1  # сумму нужно уменьшить => идем правым указателем влево
            else:
                # сумма равна 0
                result.append([arr[i], arr[j], arr[k]])
                j += 1
                k -= 1
                # Пропускаем повторяющиеся числа для второго элемента
                while j < k and arr[j] == arr[j - 1]:
                    j += 1
                # Пропускаем повторяющиеся числа для третьего элемента
                while j < k < n - 1 and arr[k] == arr[k + 1]:
                    k -= 1
    return result


# Пример использования
arr = [-1, 0, 1, 2, -1, -4]
print(three_sum_zero(arr))  # Вывод: [[-1, -1, 2], [-1, 0, 1]]

arr = [-1, 0, 1, 2, -1, -4, 1, 1, 1, -1, 0, -2]
print(three_sum_zero(arr))  # Вывод: [[-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1]]

arr = [-2, -1, 0, 1, 3, 4]
print(three_sum_zero(arr))  # Вывод: [[-2, -1, 3], [-1, 0, 1]]

arr = [-1, 0, 1, 2, -1, -4, 1, 1, 1, -1, 0, -2, 2]
print(three_sum_zero(arr))  # Вывод: [[-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1]]

