\chapter{Аналитическая часть}

\section{Поиск полным перебором}

При использовании метода поиска полным перебором происходит последовательный просмотр элементов массива и сравнении каждого из них с образцом для поиска~\cite{lit1}.

Для алгоритма нахождения искомого значения в массиве полным перебором количество исходов равно $N+1$: искомое значение не найдено и $N$ возможных случаев расположения элемента в массиве. Лучший случай: за одно сравнение ключ найден в начале массива. Худших случаев два: за N сравнений либо элемент не найден, либо элемент найден на последнем сравнении. 
% Пусть на старте алгоритм затрачивает $k_0$ сравнений, а при каждом сравнении $k_1$ сравнений. Тогда в лучшем случае $k_0 + k_1$ сравнений, а т.~к. после каждого следующего сравнения число сравнений увеличивалось на $k_1$, то количество сравнений представимо в виде арифметической прогрессии, т.~е. количество сравнений в худшем случае: $k_0 + N*k_1$. Тогда среднее количество сравнений равно сумме сравнений для каждого случая, поделенное на количество случаев~\ref{eq:lin_search}.


%\begin{equation}
%	\label{eq:lin_search}
%	\begin{split}
%		f_{cp} = N*\frac{k_0 + k_1 + k_0 + N*k_1}{2} * \frac{1}{N+1} +  \frac{k_0 + N*k_1}{N+1} = \\
%		= \frac{(N+1)*(k_0 + \frac{N+1}{2}*N*k_1 + N*k_1)}{N+1} = \\
%		= k_0 + k_1*(\frac{N}{N+1} + \frac{N}{2})
%	\end{split}
%\end{equation}

\section{Двоичный поиск}

При использовании метода двоичного поиска предполагается, что массив в котором осуществляется поиск уже упорядочен. Вводятся левая и правая граница поиска.
Выбирается центральный элемент в области между границами поиска и сравнивается с искомым значением. Если искомое значение меньше центрального элемента, то центральный элемент становится правой границей, если искомое значение больше центрального элемента, то центральный элемент становится левой границей, в оставшемся случае искомое значение найдено. Сравнения повторяются пока границы не сойдутся или искомое значение будет найдено. Если левая граница станет больше правой, а искомое значение не будет найдено, то его нет в массиве~\cite{lit2}.

Лучший случай: за одно сравнение ключ найден в середине массива. Худших случаев два: за $\lceil \log_2 N\rceil$ сравнений либо элемент не найден, либо элемент найден на последнем сравнении.
% Пусть на старте алгоритм затрачивает $k_0$ сравнений, а при каждом сравнении $k_1$ сравнений. Лучший случай $k_0 + k_1$ сравнений, тогда при следующем сравнении определится еще 2 исхода (в зависимости от результата первого сравнения, в середине первой половины или в середине второй половины), для чего совершится уже $k_0 + 2*k_1$, затем еще 4 исхода и $k_0 + 3*k_1$. Тогда среднее количество сравнений равно сумме сравнений для каждого случая, поделенное на количество случаев~\ref{eq:bin_search}.


%\begin{equation}
%	\label{eq:bin_search}
%	\begin{split}
	%	f_{cp} = (N+1)*\frac{k_0}{N+1} + k_1 * (\frac{2^{\lfloor \log_2 N\rfloor} - 1}{N+1} + \frac{(N + 1 - (2^{\lfloor \log_2 N\rfloor} - 1))* \lceil \log_2 N\rceil }{N+1}) = \\
	%	= k_0+ k_1 * \frac{2^{\lfloor \log_2 N\rfloor} - 1 + (N - 2^{\lfloor \log_2 N\rfloor} )* \lceil \log_2 N\rceil }{N+1}
	%\end{split}
%\end{equation}

\section*{Вывод}

В данном разделе рассмотрены алгоритмы нахождения искомого значения в массиве.

\clearpage
